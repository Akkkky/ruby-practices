#!/usr/bin/env ruby
# frozen_string_literal: true

require 'optparse'
require 'etc'
require 'pathname'

RENDERING_COL_LENGTH = 8

def main
  option = ARGV.getopts('l')

  if ARGV[0]
    arguments = ARGV
    is_arguments_file = true
  else
    arguments = store_standard_input
    is_arguments_file = false
  end

  run_wc(arguments, is_arguments_file, option)
end

def run_wc(arguments, is_arguments_file, option)
  if is_arguments_file
    results = retrieve_files(arguments)
    render_argument_files(results, option)
  else
    results = build_data(arguments)
    render_standard_input(results, option)
  end
end

def build_data(arguments)
  {
    lines: count_number_of_lines(arguments),
    words: count_number_of_words(arguments),
    bytes: count_number_of_bytes(arguments)
  }
end

def store_standard_input
  inputs = []
  while (line = $stdin.gets)
    inputs << line unless line.chomp.empty?
  end
  inputs
end

def count_number_of_lines(arguments)
  # mac の wc に準拠して、lines ではなく改行コードの数を count
  arguments.instance_of?(Array) ? arguments.length : arguments.count("\n")
end

def count_number_of_words(arguments)
  if arguments.instance_of?(Array)
    arguments.each.sum do |argument|
      argument.split.length
    end
  else
    arguments.strip.split(/\s+/).length
  end
end

def count_number_of_bytes(arguments)
  arguments.instance_of?(Array) ? arguments.each.sum(&:bytesize) : arguments.bytesize
end

def retrieve_files(arguments)
  results = []
  arguments.each do |argument|
    file_path = Pathname("./#{argument}")

    if File.exist?(file_path)
      file_data = get_file_data(file_path)
      results << file_data
    else
      results << "wc: #{argument}: open: No such file or directory"
    end
  end
  results
end

def get_file_data(file_path)
  stat = File.lstat(file_path)

  if stat.directory?
    "wc: #{File.basename(file_path)}: read: Is a directory"
  else
    fils_string = File.read(file_path)
    result = build_data(fils_string)
    result[:file_name] = File.basename(file_path)
    result
  end
end

def render_standard_input(result, option)
  puts justify_output(result, option)
end

def render_argument_files(results, option)
  total = { lines: 0, words: 0, bytes: 0 }
  results.each do |result|
    if result.instance_of?(Hash)
      puts justify_output(result, option, result[:file_name])
      total = sum_file_size(result, total)
    else
      puts result
    end
  end
  (puts justify_output(total, option, 'total')) if results.length > 1
end

def justify_output(result, option, additional = '')
  if option['l']
    "#{result[:lines].to_s.rjust(RENDERING_COL_LENGTH)} #{additional}"
  else
    [
      result[:lines].to_s.rjust(RENDERING_COL_LENGTH),
      result[:words].to_s.rjust(RENDERING_COL_LENGTH),
      result[:bytes].to_s.rjust(RENDERING_COL_LENGTH),
      " #{additional}"
    ].join
  end
end

def sum_file_size(file_data, total)
  file_data.each_key do |key|
    total[key] += file_data[key] unless key == :file_name
  end
  total
end

main
